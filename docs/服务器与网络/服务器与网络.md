# 服务器与网络

## 常见状态码

| 数据 | 类型                          | 原因短语                           |
| ---- | ----------------------------- | ---------------------------------- |
| 1xx  | Informational（信息性状态码） | 接受的请求正在处理                 |
| 2xx  | Success（成功状态码）         | 请求正常处理完毕                   |
| 3xx  | Redirection（重定向）         | 需要进行附加操作以完成请求         |
| 4xx  | Client error（客户端错误）    | 客户端请求出错，服务器无法处理请求 |
| 5xx  | Server Error（服务器错误）    | 服务器处理请求出错                 |

- 2xx （3 种）
  - 200 OK：表示从客户端发送给服务器的请求被正常处理并返回；
  - 204 No Content：表示客户端发送给客户端的请求得到了成功处理，但在返回的响应报文中不含实体的主体部分（没有资源可以返回）；
    > 意思等同于请求执行成功，但是没有数据，浏览器不用刷新页面.也不用导向新的页面。如何理解这段话呢。还是通过例子来说明吧，假设页面上有个 form，提交的 url 为 http-204.htm，提交 form，正常情况下，页面会跳转到 http-204.htm，但是如果 http-204.htm 的相应的状态码是 204，此时页面就不会发生转跳，还是停留在当前页面。另外对于 a 标签，如果链接的页面响应码为 204，页面也不会发生跳转。所以对于一些提交到服务器处理的数据，只需要返回是否成功的情况下，可以考虑使用状态码 204 来作为返回信息，从而省掉多余的数据传输。
  - 206 Patial Content：表示客户端进行了范围请求，并且服务器成功执行了这部分的 GET 请求，响应报文中包含由 Content-Range 指定范围的实体内容。
- 3xx （5 种）
  - 301 Moved Permanently：永久性重定向，表示请求的资源被分配了新的 URL，之后应使用更改的 URL；
  - 302 Found：临时性重定向，表示请求的资源被分配了新的 URL，希望本次访问使用新的 URL；
    - 301 与 302 的区别：前者是永久移动，后者是临时移动（之后可能还会更改 URL）
  - 303 See Other：表示请求的资源被分配了新的 URL，应使用 GET 方法定向获取请求的资源；
    - 302 与 303 的区别：后者明确表示客户端应当采用 GET 方式获取资源
  - 304 Not Modified：表示客户端发送附带条件（是指采用 GET 方法的请求报文中包含 if-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since 中任一首部）的请求时，服务器端允许访问资源，但是请求为满足条件的情况下返回改状态码；
  - 307 Temporary Redirect：临时重定向，与 303 有着相同的含义，307 会遵照浏览器标准不会从 POST 变成 GET；（不同浏览器可能会出现不同的情况）；
- 4xx （4 种）
  - 400 Bad Request：表示请求报文中存在语法错误；
  - 401 Unauthorized：未经许可，需要通过 HTTP 认证；
  - 403 Forbidden：服务器拒绝该次访问（访问权限出现问题）
  - 404 Not Found：表示服务器上无法找到请求的资源，除此之外，也可以在服务器拒绝请求但不想给拒绝原因时使用；
- 5xx （2 种）
  - 500 Inter Server Error：表示服务器在执行请求时发生了错误，也有可能是 web 应用存在的 bug 或某些临时的错误时；
  - 503 Server Unavailable：表示服务器暂时处于超负载或正在进行停机维护，无法处理请求；

## 缓存

- 200 From cache 和 200 ok
- 400,401,403 状态码分别代表什么
- 前端缓存主要是分为 HTTP 缓存和浏览器缓存。其中 HTTP 缓存是在 HTTP 请求传输时用到的缓存，主要在服务器代码上设置；而浏览器缓存则主要由前端开发在前端 js 上进行设置。缓存可以说是性能优化中简单高效的一种优化方式了。一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。比如说直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，那么就没有必要再将数据回传回来，这样就减少了响应数据。
  https://www.jianshu.com/p/256d0873c398

## 浏览器缓存

## cookie, session, token

## 前端持久化的方式、区别 （数据持久化）

- cookie
- localStorage
- sessionStorage
- indexDB
- web SQL （html5 已放弃？）

## DNS 是怎么解析的

DNS（Domain Name Server，域名服务器）是进行域名(domain name)和与之相对应的 IP 地址 (IP address)转换的服务器。DNS 中保存了一张域名(domain name)和与之相对应的 IP 地址 (IP address)的表，以解析消息的域名。 域名是 Internet 上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位（有时也指地理位置）。域名是由一串用点分隔的名字组成的，通常包含组织名，而且始终包括两到三个字母的后缀，以指明组织的类型或该域所在的国家或地区。
具体过程如下：

1. 用户主机上运行着 DNS 的客户端，就是我们的 PC 机或者手机客户端运行着 DNS 客户端了
2. 浏览器将接收到的 url 中抽取出域名字段，就是访问的主机名，比如http://www.baidu.com/, 并将这个主机名传送给 DNS 应用的客户端
3. DNS 客户机端向 DNS 服务器端发送一份查询报文，报文中包含着要访问的主机名字段（中间包括一些列缓存查询以及分布式 DNS 集群的工作）
4. 该 DNS 客户机最终会收到一份回答报文，其中包含有该主机名对应的 IP 地址
5. 一旦该浏览器收到来自 DNS 的 IP 地址，就可以向该 IP 地址定位的 HTTP 服务器发起 TCP 连接

解析顺序

1. 浏览器缓存
当用户通过浏览器访问某域名时，浏览器首先会在自己的缓存中查找是否有该域名对应的 IP 地址（若曾经访问过该域名且没有清空缓存便存在）；
2. 系统缓存
当浏览器缓存中无域名对应 IP 则会自动检查用户计算机系统 Hosts 文件 DNS 缓存是否有该域名对应 IP；
3. 路由器缓存
当浏览器及系统缓存中均无域名对应 IP 则进入路由器缓存中检查，以上三步均为客服端的 DNS 缓存；
4. ISP（互联网服务提供商）DNS 缓存
当在用户客服端查找不到域名对应 IP 地址，则将进入 ISP DNS 缓存中进行查询。比如你用的是电信的网络，则会进入电信的 DNS 缓存服务器中进行查找；
5. 根域名服务器
当以上均未完成，则进入根服务器进行查询。全球仅有 13 台根域名服务器，1 个主根域名服务器，其余 12 为辅根域名服务器。根域名收到请求后会查看区域文件记录，若无则将其管辖范围内顶级域名（如.com）服务器 IP 告诉本地 DNS 服务器；
6. 顶级域名服务器
顶级域名服务器收到请求后查看区域文件记录，若无则将其管辖范围内主域名服务器的 IP 地址告诉本地 DNS 服务器；
7. 主域名服务器
主域名服务器接受到请求后查询自己的缓存，如果没有则进入下一级域名服务器进行查找，并重复该步骤直至找到正确纪录；
8. 保存结果至缓存
本地域名服务器把返回的结果保存到缓存，以备下一次使用，同时将该结果反馈给客户端，客户端通过这个 IP 地址与 web 服务器建立链接。

## cdn
CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。

## 计算机网络的相关协议

## http/https/http2.0

- HTTP
  - 全称超文本传输协议（HTTP，HyperText Transfer Protocol)，是一个客户端和服务器端请求和应答的标准（TCP），互联网上应用最为广泛的一种网络协议。客户端是终端用户，服务器端是网站。
  - 通过使用 Web 浏览器、网络爬虫或者其它的工具，客户端发起一个到服务器上指定端口（默认端口为 80）的 HTTP 请求。
  - HTTP 是建立在 TCP 协议之上，所以 HTTP 协议的瓶颈及其优化技巧都是基于 TCP 协议本身的特性，例如 tcp 建立连接的 3 次握手和断开连接的 4 次挥手以及每次建立连接带来的 RTT 延迟时间。
  - 特点：
    1. 无状态性。当客户端访问完一次服务器再次访问的时候，服务器是无法知道这个客户端之前是否已经访问过了。优点是不需要先前的信息，能够更快的应答，缺点是每次连接传送的数据量增大。
    2. 持久连接。HTTP1.1 使用持久连接 keepalive，所谓持久连接，就是服务器在发送响应后仍然在一段时间内保持这条连接，允许在同一个连接中存在多次数据请求和响应，即在持久连接情况下，服务器在发送完响应后并不关闭 TCP 连接，客户端可以通过这个连接继续请求其他对象。
    3. 其他。支持客户/服务器模式、简单快速（请求方法简单 Get 和 POST）、灵活（数据对象任意）
  - 影响效率因素
    1. 带宽
    2. 延迟。 浏览器阻塞（一个浏览器对于同一个域名，同时只能有 4 个链接，超出后就会被阻塞）
    3. DNS 查询
    4. 建立连接。 （HTTP 是基于 TCP 协议的，即使网络、浏览器再快也要进行 TCP 的三次握手，在高延迟的场景下影响比较明显，慢启动则对文件请求影响较大。）
  - 缺陷
    1. 耗时：传输数据每次都要建立连接；
    2. 不安全：HTTP 是明文传输的，只要在路由器或者交换机上截取，所有东西（账号密码）都是可见的；
    3. Header 内容过大：通常，客户端的请求 header 变化较小，但是每次都要携带大量的 header 信息，导致传输成本增大；
    4. keepalive 压力过大：持久连接虽然有一点的优点，但同时也会给服务器造成大量的性能压力，特别是传输图片的时候。
- HTTPS，即加密后的 HTTP。HTTP 协议传输的数据都是未加密的，也就是明文的，因此使用 HTTP 协议传输隐私信息非常不安全。HTTPS 都是用的 TLS 协议。

## get post 区别

- get
  1. GET 请求可被缓存
  2. GET 请求保留在浏览器历史记录中
  3. GET 请求可被收藏为书签
  4. GET 请求不应在处理敏感数据时使用(不安全)
  5. GET 请求有长度限制
  6. GET 请求只应当用于取回数据(不能请求图片等二进制资源)
- post
  1. POST 请求不会被缓存
  2. POST 请求不会保留在浏览器历史记录中
  3. POST 不能被收藏为书签
  4. POST 请求对数据长度没有要求
  5. 数据不会显示在 URL 中(安全)

## ajax/axios/fetch
https://www.jianshu.com/p/8bc48f8fde75
* ajax
优点
1. 封装XMLHttpRequest
2. 成熟，方便，支持跨域jsonp
3. 取消请求 abort()方法
缺点
1. 回调地狱
* axios
优点
1. 封装XMLHttpRequest
2. 支持 Promise API
3. 客户端支持防止CSRF
4. 提供了一些并发请求的接口（重要，方便了很多的操作）
5. 从 node.js 创建 http 请求
6. 拦截请求和响应
7. 转换请求和响应数据
8. 取消请求 axios.CancelToken.source()
9. 自动转换JSON数据
10. 实现跨域proxyTable


## tcp 三次握手，四次挥手流程

- tcp 三次握手(请求有可能丢失)
  1. 客户端–发送带有 SYN 标志的数据包–一次握手–服务端
  2. 服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端
  3. 客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端

## 跨域

## 前端安全 XSS、CSRF

## websocket（下面有介绍）

## Http 请求中的 keep-alive 有了解吗

## 网络分层

## 即时通信，除了 Ajax 和 websocket

1. 短轮询

- 短轮询的原理很简单，每隔一段时间客户端就发出一个请求，去获取服务器最新的数据，一定程度上模拟实现了即时通讯。
  - 优点：兼容性强，实现非常简单
  - 缺点：延迟性高，非常消耗请求资源，影响性能

2. comet（彗星）

- comet 有两种主要实现手段，一种是基于 AJAX 的长轮询（long-polling）方式，另一种是基于 Iframe 及 htmlfile 的流（streaming）方式，通常被叫做长连接。
- 具体两种手段的操作方法请移步 Comet 技术详解：基于 HTTP 长连接的 Web 端实时通信技术
- 长轮询优缺点：

  - 优点：兼容性好，资源浪费较小
  - 缺点：服务器 hold 连接会消耗资源，返回数据顺序无保证，难于管理维护

- 长连接优缺点：
  - 优点：兼容性好，消息即时到达，不发无用请求
  - 缺点：服务器维护长连接消耗资源

3. SSE 使用指南请看 Server-Sent Events 教程

- SSE（Server-Sent Event，服务端推送事件）是一种允许服务端向客户端推送新数据的 HTML5 技术
- Server-sent Events 规范是 HTML 5 规范的一个组成部分,该规范比较简单，主要由两个部分组成：第一个部分是服务器端与浏览器端之间的通讯协议，第二部分则是在浏览器端可供 JavaScript 使用的 EventSource 对象
  - 优点：基于 HTTP 而生，因此不需要太多改造就能使用，使用方便，而 websocket 非常复杂，必须借助成熟的库或框架
  - 缺点：基于文本传输效率没有 websocket 高，不是严格的双向通信，客户端向服务端发送请求无法复用之前的连接，需要重新发出独立的请求。IE 浏览器存在兼容问题，解决办法引入第三方库，解决浏览器差异问题。

4. Websocket

- Websocket 是一个全新的、独立的协议，基于 TCP 协议，与 http 协议兼容、却不会融入 http 协议，仅仅作为 html5 的一部分，其作用就是在服务器和客户端之间建立实时的双向通信。
- Socket.IO 是一个完全由 JavaScript 实现、基于 Node.js、支持 WebSocket 的协议用于实时通信、跨平台的开源框架，它包括了客户端的 JavaScript 和服务器端的 Node.js。Socket.IO 除了支持 WebSocket 通讯协议外，还支持许多种轮询（Polling）机制以及其它实时通信方式，并封装成了通用的接口，并且在服务端实现了这些实时机制的相应代码。Socket.IO 实现的 Polling 通信机制包括 Adobe Flash Socket、AJAX 长轮询、AJAX multipart streaming、持久 Iframe、JSONP 轮询等。Socket.IO 能够根据浏览器对通讯机制的支持情况自动地选择最佳的方式来实现网络实时应用。
  - 优点：真正意义上的实时双向通信，性能好，低延迟
  - 缺点：独立与 http 的协议，因此需要额外的项目改造，使用复杂度高，必须引入成熟的库，无法兼容低版本浏览器

5. Web Worker

- Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行

6. Service workers

- Service workers 本质上充当 Web 应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理，创建有效的离线体验。

## 模块化，commonJS，es6，cmd，amd
