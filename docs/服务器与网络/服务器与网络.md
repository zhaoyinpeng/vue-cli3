# 服务器与网络
## 常见状态码
  数据|类型|原因短语
  -|-|-
  1xx	|Informational（信息性状态码）|	接受的请求正在处理
  2xx	|Success（成功状态码）|	请求正常处理完毕
  3xx	|Redirection（重定向）|	需要进行附加操作以完成请求
  4xx	|Client error（客户端错误）|	客户端请求出错，服务器无法处理请求
  5xx	|Server Error（服务器错误）|	服务器处理请求出错

  * 2xx （3种）
    * 200 OK：表示从客户端发送给服务器的请求被正常处理并返回；
    * 204 No Content：表示客户端发送给客户端的请求得到了成功处理，但在返回的响应报文中不含实体的主体部分（没有资源可以返回）；
    * 206 Patial Content：表示客户端进行了范围请求，并且服务器成功执行了这部分的GET请求，响应报文中包含由Content-Range指定范围的实体内容。
  * 3xx （5种）
    * 301 Moved Permanently：永久性重定向，表示请求的资源被分配了新的URL，之后应使用更改的URL；
    * 302 Found：临时性重定向，表示请求的资源被分配了新的URL，希望本次访问使用新的URL；
      * 301与302的区别：前者是永久移动，后者是临时移动（之后可能还会更改URL）
    * 303 See Other：表示请求的资源被分配了新的URL，应使用GET方法定向获取请求的资源；
      * 302与303的区别：后者明确表示客户端应当采用GET方式获取资源
    * 304 Not Modified：表示客户端发送附带条件（是指采用GET方法的请求报文中包含if-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since中任一首部）的请求时，服务器端允许访问资源，但是请求为满足条件的情况下返回改状态码；
    * 307 Temporary Redirect：临时重定向，与303有着相同的含义，307会遵照浏览器标准不会从POST变成GET；（不同浏览器可能会出现不同的情况）；
  * 4xx （4种）
    * 400 Bad Request：表示请求报文中存在语法错误；
    * 401 Unauthorized：未经许可，需要通过HTTP认证；
    * 403 Forbidden：服务器拒绝该次访问（访问权限出现问题）
    * 404 Not Found：表示服务器上无法找到请求的资源，除此之外，也可以在服务器拒绝请求但不想给拒绝原因时使用；
  * 5xx （2种）
    * 500 Inter Server Error：表示服务器在执行请求时发生了错误，也有可能是web应用存在的bug或某些临时的错误时；
    * 503 Server Unavailable：表示服务器暂时处于超负载或正在进行停机维护，无法处理请求；
## 缓存
* 200 From cache和200 ok
* 400,401,403状态码分别代表什么
* 前端缓存主要是分为HTTP缓存和浏览器缓存。其中HTTP缓存是在HTTP请求传输时用到的缓存，主要在服务器代码上设置；而浏览器缓存则主要由前端开发在前端js上进行设置。缓存可以说是性能优化中简单高效的一种优化方式了。一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。比如说直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，那么就没有必要再将数据回传回来，这样就减少了响应数据。
https://www.jianshu.com/p/256d0873c398
## 浏览器缓存
## cookie, session, token
## 前端持久化的方式、区别 （数据持久化）
* cookie
* localStorage
* sessionStorage
* indexDB
* web SQL （html5已放弃？）
## DNS是怎么解析的
## cdn
## 计算机网络的相关协议
## http/https/http2.0
* HTTP
  * 全称超文本传输协议（HTTP，HyperText Transfer Protocol)，是一个客户端和服务器端请求和应答的标准（TCP），互联网上应用最为广泛的一种网络协议。客户端是终端用户，服务器端是网站。
  * 通过使用Web浏览器、网络爬虫或者其它的工具，客户端发起一个到服务器上指定端口（默认端口为80）的HTTP请求。
  * HTTP是建立在TCP协议之上，所以HTTP协议的瓶颈及其优化技巧都是基于TCP协议本身的特性，例如tcp建立连接的3次握手和断开连接的4次挥手以及每次建立连接带来的RTT延迟时间。
  * 特点： 
    1. 无状态性。当客户端访问完一次服务器再次访问的时候，服务器是无法知道这个客户端之前是否已经访问过了。优点是不需要先前的信息，能够更快的应答，缺点是每次连接传送的数据量增大。
    2. 持久连接。HTTP1.1 使用持久连接keepalive，所谓持久连接，就是服务器在发送响应后仍然在一段时间内保持这条连接，允许在同一个连接中存在多次数据请求和响应，即在持久连接情况下，服务器在发送完响应后并不关闭TCP连接，客户端可以通过这个连接继续请求其他对象。
    3. 其他。支持客户/服务器模式、简单快速（请求方法简单Get和POST）、灵活（数据对象任意）
  * 影响效率因素
    1. 带宽
    2. 延迟。 浏览器阻塞（一个浏览器对于同一个域名，同时只能有4个链接，超出后就会被阻塞）
    3. DNS查询
    4. 建立连接。 （HTTP是基于TCP协议的，即使网络、浏览器再快也要进行TCP的三次握手，在高延迟的场景下影响比较明显，慢启动则对文件请求影响较大。）
  * 缺陷
    1. 耗时：传输数据每次都要建立连接；
    2. 不安全：HTTP是明文传输的，只要在路由器或者交换机上截取，所有东西（账号密码）都是可见的；
    3. Header内容过大：通常，客户端的请求header变化较小，但是每次都要携带大量的header信息，导致传输成本增大；
    4. keepalive压力过大：持久连接虽然有一点的优点，但同时也会给服务器造成大量的性能压力，特别是传输图片的时候。
* HTTPS，即加密后的HTTP。HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全。HTTPS都是用的TLS协议。
## get post区别
* get
  1. GET 请求可被缓存
  2. GET 请求保留在浏览器历史记录中
  3. GET 请求可被收藏为书签
  4. GET 请求不应在处理敏感数据时使用(不安全)
  5. GET 请求有长度限制
  6. GET 请求只应当用于取回数据(不能请求图片等二进制资源)
* post
  1. POST 请求不会被缓存
  2. POST 请求不会保留在浏览器历史记录中
  3. POST 不能被收藏为书签
  4. POST 请求对数据长度没有要求
  5. 数据不会显示在 URL 中(安全)
## ajax、 axios库
## tcp三次握手，四次挥手流程
* tcp三次握手(请求有可能丢失)
  1. 客户端–发送带有SYN标志的数据包–一次握手–服务端
  2. 服务端–发送带有SYN/ACK标志的数据包–二次握手–客户端
  3. 客户端–发送带有带有ACK标志的数据包–三次握手–服务端
## 跨域
## 前端安全XSS、CSRF
## websocket（下面有介绍）
## Http请求中的keep-alive有了解吗
## 网络分层
## 即时通信，除了Ajax和websocket
1. 短轮询
* 短轮询的原理很简单，每隔一段时间客户端就发出一个请求，去获取服务器最新的数据，一定程度上模拟实现了即时通讯。
  * 优点：兼容性强，实现非常简单
  * 缺点：延迟性高，非常消耗请求资源，影响性能

2. comet（彗星）
* comet有两种主要实现手段，一种是基于 AJAX 的长轮询（long-polling）方式，另一种是基于 Iframe 及 htmlfile 的流（streaming）方式，通常被叫做长连接。
* 具体两种手段的操作方法请移步Comet技术详解：基于HTTP长连接的Web端实时通信技术
* 长轮询优缺点：
  * 优点：兼容性好，资源浪费较小
  * 缺点：服务器hold连接会消耗资源，返回数据顺序无保证，难于管理维护

* 长连接优缺点：
  * 优点：兼容性好，消息即时到达，不发无用请求
  * 缺点：服务器维护长连接消耗资源

3. SSE 使用指南请看Server-Sent Events 教程
* SSE（Server-Sent Event，服务端推送事件）是一种允许服务端向客户端推送新数据的HTML5技术
* Server-sent Events 规范是 HTML 5 规范的一个组成部分,该规范比较简单，主要由两个部分组成：第一个部分是服务器端与浏览器端之间的通讯协议，第二部分则是在浏览器端可供 JavaScript 使用的 EventSource 对象
  * 优点：基于HTTP而生，因此不需要太多改造就能使用，使用方便，而websocket非常复杂，必须借助成熟的库或框架
  * 缺点：基于文本传输效率没有websocket高，不是严格的双向通信，客户端向服务端发送请求无法复用之前的连接，需要重新发出独立的请求。IE浏览器存在兼容问题，解决办法引入第三方库，解决浏览器差异问题。

4. Websocket
* Websocket是一个全新的、独立的协议，基于TCP协议，与http协议兼容、却不会融入http协议，仅仅作为html5的一部分，其作用就是在服务器和客户端之间建立实时的双向通信。
* Socket.IO是一个完全由JavaScript实现、基于Node.js、支持WebSocket的协议用于实时通信、跨平台的开源框架，它包括了客户端的JavaScript和服务器端的Node.js。Socket.IO除了支持WebSocket通讯协议外，还支持许多种轮询（Polling）机制以及其它实时通信方式，并封装成了通用的接口，并且在服务端实现了这些实时机制的相应代码。Socket.IO实现的Polling通信机制包括Adobe Flash Socket、AJAX长轮询、AJAX multipart streaming、持久Iframe、JSONP轮询等。Socket.IO能够根据浏览器对通讯机制的支持情况自动地选择最佳的方式来实现网络实时应用。
  * 优点：真正意义上的实时双向通信，性能好，低延迟
  * 缺点：独立与http的协议，因此需要额外的项目改造，使用复杂度高，必须引入成熟的库，无法兼容低版本浏览器

5. Web Worker
* Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行

6. Service workers
* Service workers 本质上充当Web应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理，创建有效的离线体验。
## 模块化，commonJS，es6，cmd，amd
