# 服务器与网络

## 常见状态码

| 数据 | 类型                          | 原因短语                           |
| ---- | ----------------------------- | ---------------------------------- |
| 1xx  | Informational（信息性状态码） | 接受的请求正在处理                 |
| 2xx  | Success（成功状态码）         | 请求正常处理完毕                   |
| 3xx  | Redirection（重定向）         | 需要进行附加操作以完成请求         |
| 4xx  | Client error（客户端错误）    | 客户端请求出错，服务器无法处理请求 |
| 5xx  | Server Error（服务器错误）    | 服务器处理请求出错                 |

- 2xx （3 种）
  - 200 OK：表示从客户端发送给服务器的请求被正常处理并返回；
  - 204 No Content：表示客户端发送给客户端的请求得到了成功处理，但在返回的响应报文中不含实体的主体部分（没有资源可以返回）；
    > 意思等同于请求执行成功，但是没有数据，浏览器不用刷新页面.也不用导向新的页面。如何理解这段话呢。还是通过例子来说明吧，假设页面上有个 form，提交的 url 为 http-204.htm，提交 form，正常情况下，页面会跳转到 http-204.htm，但是如果 http-204.htm 的相应的状态码是 204，此时页面就不会发生转跳，还是停留在当前页面。另外对于 a 标签，如果链接的页面响应码为 204，页面也不会发生跳转。所以对于一些提交到服务器处理的数据，只需要返回是否成功的情况下，可以考虑使用状态码 204 来作为返回信息，从而省掉多余的数据传输。
  - 206 Patial Content：表示客户端进行了范围请求，并且服务器成功执行了这部分的 GET 请求，响应报文中包含由 Content-Range 指定范围的实体内容。
- 3xx （5 种）
  - 301 Moved Permanently：永久性重定向，表示请求的资源被分配了新的 URL，之后应使用更改的 URL；
  - 302 Found：临时性重定向，表示请求的资源被分配了新的 URL，希望本次访问使用新的 URL；
    - 301 与 302 的区别：前者是永久移动，后者是临时移动（之后可能还会更改 URL）
  - 303 See Other：表示请求的资源被分配了新的 URL，应使用 GET 方法定向获取请求的资源；
    - 302 与 303 的区别：后者明确表示客户端应当采用 GET 方式获取资源
  - 304 Not Modified：表示客户端发送附带条件（是指采用 GET 方法的请求报文中包含 if-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since 中任一首部）的请求时，服务器端允许访问资源，但是请求为满足条件的情况下返回改状态码；
  - 307 Temporary Redirect：临时重定向，与 303 有着相同的含义，307 会遵照浏览器标准不会从 POST 变成 GET；（不同浏览器可能会出现不同的情况）；
- 4xx （4 种）
  - 400 Bad Request：表示请求报文中存在语法错误；
  - 401 Unauthorized：未经许可，需要通过 HTTP 认证；
  - 403 Forbidden：服务器拒绝该次访问（访问权限出现问题）
  - 404 Not Found：表示服务器上无法找到请求的资源，除此之外，也可以在服务器拒绝请求但不想给拒绝原因时使用；
- 5xx （2 种）
  - 500 Inter Server Error：表示服务器在执行请求时发生了错误，也有可能是 web 应用存在的 bug 或某些临时的错误时；
  - 503 Server Unavailable：表示服务器暂时处于超负载或正在进行停机维护，无法处理请求；

## 缓存

- 200 From cache 和 200 ok
- 400,401,403 状态码分别代表什么
- 前端缓存主要是分为 HTTP 缓存和浏览器缓存。其中 HTTP 缓存是在 HTTP 请求传输时用到的缓存，主要在服务器代码上设置；而浏览器缓存则主要由前端开发在前端 js 上进行设置。缓存可以说是性能优化中简单高效的一种优化方式了。一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。比如说直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，那么就没有必要再将数据回传回来，这样就减少了响应数据。
  https://www.jianshu.com/p/256d0873c398

## 浏览器缓存
https://www.jianshu.com/p/54cc04190252
太长了，就不在这里赘述
1. 存储位置
- Service Worker
(1)Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。
(2)使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。
(3)Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。
- Memory Cache
- Disk Cache
- Push Cache

### 缓存过程分析
![Image text](./1.webp)


## cookie, session, token

## 前端持久化的方式、区别 （数据持久化）

- cookie
- localStorage
- sessionStorage
- indexDB
- web SQL （html5 已放弃？）

## DNS 是怎么解析的

DNS（Domain Name Server，域名服务器）是进行域名(domain name)和与之相对应的 IP 地址 (IP address)转换的服务器。DNS 中保存了一张域名(domain name)和与之相对应的 IP 地址 (IP address)的表，以解析消息的域名。 域名是 Internet 上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位（有时也指地理位置）。域名是由一串用点分隔的名字组成的，通常包含组织名，而且始终包括两到三个字母的后缀，以指明组织的类型或该域所在的国家或地区。
具体过程如下：

1. 用户主机上运行着 DNS 的客户端，就是我们的 PC 机或者手机客户端运行着 DNS 客户端了
2. 浏览器将接收到的 url 中抽取出域名字段，就是访问的主机名，比如http://www.baidu.com/, 并将这个主机名传送给 DNS 应用的客户端
3. DNS 客户机端向 DNS 服务器端发送一份查询报文，报文中包含着要访问的主机名字段（中间包括一些列缓存查询以及分布式 DNS 集群的工作）
4. 该 DNS 客户机最终会收到一份回答报文，其中包含有该主机名对应的 IP 地址
5. 一旦该浏览器收到来自 DNS 的 IP 地址，就可以向该 IP 地址定位的 HTTP 服务器发起 TCP 连接

解析顺序

1. 浏览器缓存
   当用户通过浏览器访问某域名时，浏览器首先会在自己的缓存中查找是否有该域名对应的 IP 地址（若曾经访问过该域名且没有清空缓存便存在）；
2. 系统缓存
   当浏览器缓存中无域名对应 IP 则会自动检查用户计算机系统 Hosts 文件 DNS 缓存是否有该域名对应 IP；
3. 路由器缓存
   当浏览器及系统缓存中均无域名对应 IP 则进入路由器缓存中检查，以上三步均为客服端的 DNS 缓存；
4. ISP（互联网服务提供商）DNS 缓存
   当在用户客服端查找不到域名对应 IP 地址，则将进入 ISP DNS 缓存中进行查询。比如你用的是电信的网络，则会进入电信的 DNS 缓存服务器中进行查找；
5. 根域名服务器
   当以上均未完成，则进入根服务器进行查询。全球仅有 13 台根域名服务器，1 个主根域名服务器，其余 12 为辅根域名服务器。根域名收到请求后会查看区域文件记录，若无则将其管辖范围内顶级域名（如.com）服务器 IP 告诉本地 DNS 服务器；
6. 顶级域名服务器
   顶级域名服务器收到请求后查看区域文件记录，若无则将其管辖范围内主域名服务器的 IP 地址告诉本地 DNS 服务器；
7. 主域名服务器
   主域名服务器接受到请求后查询自己的缓存，如果没有则进入下一级域名服务器进行查找，并重复该步骤直至找到正确纪录；
8. 保存结果至缓存
   本地域名服务器把返回的结果保存到缓存，以备下一次使用，同时将该结果反馈给客户端，客户端通过这个 IP 地址与 web 服务器建立链接。

## cdn

CDN 的全称是 Content Delivery Network，即内容分发网络。CDN 是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN 的关键技术主要有内容存储和分发技术。

## 计算机网络的相关协议

1. TCP/IP(Transmission Control Protocol /Internet Protocol)协议

TCP/IP 是基于 TCP 和 IP 这两个最初的协议之上的不同的通信协议的大集合
TCP 是传输控制协议，用于从应用程序到网络的数据传输控制，负责在数据传送之前将它们分割为 IP 包，然后在它们到达的时候将它们重组。
IP 是网际协议，负责计算机之间的通信，负责在因特网上发送和接收数据包。

2. HTTP(Hyper Text Transfer Protocol)协议

HTTP 协议是超文本传输协议(Hyper Text Transfer Protocol)，负责 web 服务器与 web 浏览器之间的通信，用于从 web 客户端向 web 服务器发送请求，并从 web 服务器向 web 客户端返回内容。

3. HTTPS(Secure HTTP)协议

HTTPS 协议是安全的 HTTP，在 HTTP 的基础上，增加了 SSL(Secure Sockets Layer)协议，也就是安全套接字层，用于为安全数据传输加密数据。

4. SMTP(Simple Mail Transfer Protocol)协议-----简易邮件传输协议，用于电子邮件的传输。

5. FTP(File Transfer Protocol)协议-----文件传输协议，负责计算机之间的文件传输。

6. UDP协议 UDP 是User Datagram Protocol的简称， 中文名是用户数据报协议，是OSI（Open System Interconnection，开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，IETF RFC 768是UDP的正式规范。UDP在IP报文的协议号是17。

## http/https/http2.0

- HTTP
  - 全称超文本传输协议（HTTP，HyperText Transfer Protocol)，是一个客户端和服务器端请求和应答的标准（TCP），互联网上应用最为广泛的一种网络协议。客户端是终端用户，服务器端是网站。
  - 通过使用 Web 浏览器、网络爬虫或者其它的工具，客户端发起一个到服务器上指定端口（默认端口为 80）的 HTTP 请求。
  - HTTP 是建立在 TCP 协议之上，所以 HTTP 协议的瓶颈及其优化技巧都是基于 TCP 协议本身的特性，例如 tcp 建立连接的 3 次握手和断开连接的 4 次挥手以及每次建立连接带来的 RTT 延迟时间。
  - 特点：
    1. 无状态性。当客户端访问完一次服务器再次访问的时候，服务器是无法知道这个客户端之前是否已经访问过了。优点是不需要先前的信息，能够更快的应答，缺点是每次连接传送的数据量增大。
    2. 持久连接。HTTP1.1 使用持久连接 keepalive，所谓持久连接，就是服务器在发送响应后仍然在一段时间内保持这条连接，允许在同一个连接中存在多次数据请求和响应，即在持久连接情况下，服务器在发送完响应后并不关闭 TCP 连接，客户端可以通过这个连接继续请求其他对象。
    3. 其他。支持客户/服务器模式、简单快速（请求方法简单 Get 和 POST）、灵活（数据对象任意）
  - 影响效率因素
    1. 带宽
    2. 延迟。 浏览器阻塞（一个浏览器对于同一个域名，同时只能有 4 个链接，超出后就会被阻塞）
    3. DNS 查询
    4. 建立连接。 （HTTP 是基于 TCP 协议的，即使网络、浏览器再快也要进行 TCP 的三次握手，在高延迟的场景下影响比较明显，慢启动则对文件请求影响较大。）
  - 缺陷
    1. 耗时：传输数据每次都要建立连接；
    2. 不安全：HTTP 是明文传输的，只要在路由器或者交换机上截取，所有东西（账号密码）都是可见的；
    3. Header 内容过大：通常，客户端的请求 header 变化较小，但是每次都要携带大量的 header 信息，导致传输成本增大；
    4. keepalive 压力过大：持久连接虽然有一点的优点，但同时也会给服务器造成大量的性能压力，特别是传输图片的时候。
- HTTPS，即加密后的 HTTP。HTTP 协议传输的数据都是未加密的，也就是明文的，因此使用 HTTP 协议传输隐私信息非常不安全。HTTPS 都是用的 TLS 协议。

## get post 区别

- get
  1. GET 请求可被缓存
  2. GET 请求保留在浏览器历史记录中
  3. GET 请求可被收藏为书签
  4. GET 请求不应在处理敏感数据时使用(不安全)
  5. GET 请求有长度限制
  6. GET 请求只应当用于取回数据(不能请求图片等二进制资源)
- post
  1. POST 请求不会被缓存
  2. POST 请求不会保留在浏览器历史记录中
  3. POST 不能被收藏为书签
  4. POST 请求对数据长度没有要求
  5. 数据不会显示在 URL 中(安全)

## ajax/axios/fetch

https://www.jianshu.com/p/8bc48f8fde75

- ajax
  优点

1. 封装 XMLHttpRequest
2. 成熟，方便，支持跨域 jsonp
3. 取消请求 abort()方法
   缺点
4. 回调地狱

- axios
  https://www.jianshu.com/p/8b0f0117918e
  优点

1. 封装 XMLHttpRequest
2. 支持 Promise API
3. 客户端支持防止 CSRF
   axios 防止 CSRF/XSRF 的原理是：设置 xsrfCookieName: 'XSRF-TOKEN' 是用作 xsrf token 的值的 cookie 的名称。
   axios 会让你的每个请求都带一个从 cookie 中拿到的 key，根据浏览器的同源策略，假冒的网站是拿不到 cookie 中的 key 的，后台可以因此辨别这个请求是否在用户假冒网站上的舞蹈输入，从而采取正确的策略
4. 提供了一些并发请求的接口（重要，方便了很多的操作）

```
function getUserAccount() {
    return axios.get('/user/12345');
}

function getUserPermissions() {
    return axios.get('/user/12345/permissions');
}

axios.all([getUserAccount(), getUserPermissions()])
    .then(axios.spread(function (acct, perms) {
        // 两个请求现在都执行完成
    }));
```

5. 从 node.js 创建 http 请求
6. 拦截请求和响应
7. 转换请求和响应数据
8. 取消请求 axios.CancelToken.source()
9. 自动转换 JSON 数据
10. 实现跨域 proxyTable

- fetch
  优点

1.  语法简洁，更加语义化
2.  基于标准 Promise 实现，支持 async/await
3.  同构方便，使用 [isomorphic-fetch](https://github.com/matthew-andrews/isomorphic-fetch)
4.  更加底层，提供的 API 丰富（request, response）
5.  脱离了 XHR，是 ES 规范里新的实现方式
    缺点
6.  fetch 只对网络请求报错，对 400，500 都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。
7.  fetch 默认不会带 cookie，需要添加配置项： fetch(url, {credentials: 'include'})
8.  fetch 不支持 abort，不支持超时控制，使用 setTimeout 及 Promise.reject 的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费
9.  fetch 没有办法原生监测请求的进度，而 XHR 可以

## tcp 三次握手，四次挥手流程

- tcp 三次握手(请求有可能丢失)
  1. 客户端–发送带有 SYN 标志的数据包–一次握手–服务端
  2. 服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端
  3. 客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端

## 跨域

- 什么是跨域
  - 使用 ajax 获取数据的时候，协议，域名，端口不一样就会形成跨域。
- 获取不到数据的原因
  - 是浏览器将数据不给前端页面，因为看到了非同源请求，所以拦截了！！
- 解决方法

  - 后台在响应头添加 Access-Control-Allow-Origin 的信息
  - 后台代理
  - jsonp

- 跨域请求和 options 请求的关系
  - 简单的跨域 不会发送 options 请求
    - get、post
  - 复杂的跨域 会发送 options 请求
    - delete、put
    - 自定义的请求头
  - options 请求就相当于浏览器向服务器询问的一次请求，问下服务器哪一些请求头可以被访问，在服务器中可以添加相应允许的请求头，就可以获取数据。

## websocket（下面有介绍）

## Http 请求中的 keep-alive 有了解吗
在早期的HTTP/1.0中，每次http请求都要创建一个连接，而创建连接的过程需要消耗资源和时间，为了减少资源消耗，缩短响应时间，就需要重用连接。在后来的HTTP/1.0中以及HTTP/1.1中，引入了重用连接的机制，就是在http请求头中加入Connection: keep-alive来告诉对方这个请求响应完成后不要关闭，下一次咱们还用这个请求继续交流。协议规定HTTP/1.0如果想要保持长连接，需要在请求头中加上Connection: keep-alive，而HTTP/1.1默认是支持长连接的，有没有这个请求头都行。

当然了，协议是这样规定的，至于支不支持还得看服务器（比如tomcat）和客户端（比如浏览器）的具体实现。在实践过程中发现谷歌浏览器使用HTTP/1.1协议时请求头中总会带上Connection: keep-alive，另外通过httpclient使用HTTP/1.0协议去请求tomcat时，即使带上Connection: keep-alive请求头也保持不了长连接。如果HTTP/1.1版本的http请求报文不希望使用长连接，则要在请求头中加上Connection: close，接收到这个请求头的对端服务就会主动关闭连接。

但是http长连接会一直保持吗？肯定是不会的。一般服务端都会设置keep-alive超时时间。超过指定的时间间隔，服务端就会主动关闭连接。同时服务端还会设置一个参数叫最大请求数，比如当最大请求数是300时，只要请求次数超过300次，即使还没到超时时间，服务端也会主动关闭连接。
## 网络分层

## 即时通信，除了 Ajax 和 websocket

1. 短轮询

- 短轮询的原理很简单，每隔一段时间客户端就发出一个请求，去获取服务器最新的数据，一定程度上模拟实现了即时通讯。
  - 优点：兼容性强，实现非常简单
  - 缺点：延迟性高，非常消耗请求资源，影响性能

2. comet（彗星）

- comet 有两种主要实现手段，一种是基于 AJAX 的长轮询（long-polling）方式，另一种是基于 Iframe 及 htmlfile 的流（streaming）方式，通常被叫做长连接。
- 具体两种手段的操作方法请移步 Comet 技术详解：基于 HTTP 长连接的 Web 端实时通信技术
- 长轮询优缺点：

  - 优点：兼容性好，资源浪费较小
  - 缺点：服务器 hold 连接会消耗资源，返回数据顺序无保证，难于管理维护

- 长连接优缺点：
  - 优点：兼容性好，消息即时到达，不发无用请求
  - 缺点：服务器维护长连接消耗资源

3. SSE 使用指南请看 Server-Sent Events 教程

- SSE（Server-Sent Event，服务端推送事件）是一种允许服务端向客户端推送新数据的 HTML5 技术
- Server-sent Events 规范是 HTML 5 规范的一个组成部分,该规范比较简单，主要由两个部分组成：第一个部分是服务器端与浏览器端之间的通讯协议，第二部分则是在浏览器端可供 JavaScript 使用的 EventSource 对象
  - 优点：基于 HTTP 而生，因此不需要太多改造就能使用，使用方便，而 websocket 非常复杂，必须借助成熟的库或框架
  - 缺点：基于文本传输效率没有 websocket 高，不是严格的双向通信，客户端向服务端发送请求无法复用之前的连接，需要重新发出独立的请求。IE 浏览器存在兼容问题，解决办法引入第三方库，解决浏览器差异问题。

4. Websocket

- Websocket 是一个全新的、独立的协议，基于 TCP 协议，与 http 协议兼容、却不会融入 http 协议，仅仅作为 html5 的一部分，其作用就是在服务器和客户端之间建立实时的双向通信。
- Socket.IO 是一个完全由 JavaScript 实现、基于 Node.js、支持 WebSocket 的协议用于实时通信、跨平台的开源框架，它包括了客户端的 JavaScript 和服务器端的 Node.js。Socket.IO 除了支持 WebSocket 通讯协议外，还支持许多种轮询（Polling）机制以及其它实时通信方式，并封装成了通用的接口，并且在服务端实现了这些实时机制的相应代码。Socket.IO 实现的 Polling 通信机制包括 Adobe Flash Socket、AJAX 长轮询、AJAX multipart streaming、持久 Iframe、JSONP 轮询等。Socket.IO 能够根据浏览器对通讯机制的支持情况自动地选择最佳的方式来实现网络实时应用。
  - 优点：真正意义上的实时双向通信，性能好，低延迟
  - 缺点：独立与 http 的协议，因此需要额外的项目改造，使用复杂度高，必须引入成熟的库，无法兼容低版本浏览器

5. Web Worker

- Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行

6. Service workers

- Service workers 本质上充当 Web 应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理，创建有效的离线体验。

## 模块化，commonJS，es6，cmd，amd
