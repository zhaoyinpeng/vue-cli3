1. v-show v-if区别
2. css在单个组件中起作用，scoped
  * scss deep 样式穿透 
  ```
  //可以使用 >>> || ::v-deep || /deep/ 
  // 用于vue项目中elementUI改变样式
    <style scoped lang='scss'>
    .parent >>> .child{
      *
    } 
    </style>
  ```
3. 移动端点击事件有300ms延迟，怎么办
 * 双击缩放，顾名思义，即用手指在屏幕上快速点击两次，iOS 自带的 Safari 浏览器会将网页缩放至原始比例。 那么这和 300 毫秒延迟有什么联系呢？ 假定这么一个场景。用户在 iOS Safari 里边点击了一个链接。由于用户可以进行双击缩放或者双击滚动的操作，当用户一次点击屏幕之后，浏览器并不能立刻判断用户是确实要打开这个链接，还是想要进行双击操作。因此，iOS Safari 就等待 300 毫秒，以判断用户是否再次点击了屏幕。
* 解决办法
  * 方案一：禁用缩放
  当HTML文档头部包含如下meta标签时：
  ```
    <meta name="viewport" content="user-scalable=no">
    <meta name="viewport" content="initial-scale=1,maximum-scale=1">
  ```
  * 方案二：更改默认的视口宽度
  一开始，为了让桌面站点能在移动端浏览器正常显示，移动端浏览器默认的视口宽度并不等于设备浏览器视窗宽度，而是要比设备浏览器视窗宽度大，通常是980px。我们可以通过以下标签来设置视口宽度为设备宽度。
  * 方案三: CSS touch-action
  ！！但是这个方法只有IE支持

* 以上三种方法都有缺点，因此可以用js方法解决
  * 方案一：指针事件的polyfill
  * 方案二：FastClick

4. 移动端点击穿透问题
  * 说完移动端点击300ms延迟的问题，还不得不提一下移动端点击穿透的问题。可能有人会想，既然click点击有300ms的延迟，那对于触摸屏，我们直接监听touchstart事件不就好了吗？使用touchstart去代替click事件有两个不好的地方。第一：touchstart是手指触摸屏幕就触发，有时候用户只是想滑动屏幕，却触发了touchstart事件，这不是我们想要的结果；第二：使用touchstart事件在某些场景下可能会出现点击穿透的现象。

  * 什么是点击穿透？假如页面上有两个元素A和B。B元素在A元素之上。我们在B元素的touchstart事件上注册了一个回调函数，该回调函数的作用是隐藏B元素。我们发现，当我们点击B元素，B元素被隐藏了，随后，A元素触发了click事件。这是因为在移动端浏览器，事件执行的顺序是touchstart > touchend > click。而click事件有300ms的延迟，当touchstart事件把B元素隐藏之后，隔了300ms，浏览器触发了click事件，但是此时B元素不见了，所以该事件被派发到了A元素身上。如果A元素是一个链接，那此时页面就会意外地跳转。

5. 什么是vue-loader
  * 项目打包时使用vue-loader将.vue文件解析成其他文件
  * vue文件的加载器

6. nextTick是做什么的
  * 说明：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。
  * 这里面涉及到异步加载dom的知识，vue中data改变后不会立即渲染dom，会异步的去渲染dom！
  * https://segmentfault.com/a/1190000012861862
  * 原理：
    * Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。
6. MutationObserver
  * Mutation observer 是用于代替 Mutation events 作为观察DOM树结构发生变化时，做出相应处理的API。
6. setImmediate
  * 暂未成为标准，暂不使用
7. mounted能替代nextTick吗？
  * https://segmentfault.com/q/1010000019401707
  * 不能！注意 mounted 不会承诺所有的子组件也都一起被挂载（里面的子组件可能未完成加载,我猜是子组件中有异步函数，例如setTimeout(0)?）。
  * ~~如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted~~ 这个可不一定哦
  * **首先，要分清宏任务和微任务。当使用$nextTick时，将在微任务(不支持微任务的浏览器将回退至宏任务)堆栈中入栈你写的回调。如果所有子组件都已经下载完毕，并在Vue中定义，则从根组件往后渲染时，因为用的都是同步方法，微任务将在这些同步方法后被执行，所以大多数时候可以通过$nextTick获取子组件渲染后的DOM节点。但是如果实例化组件的时候，有其他微任务入栈，就要看微任务队列的执行顺序了，所以无法完全保证。对于异步组件，由于网络原因，import微任务总在$nextTick之后，所以总是拿不到子组件的DOM。而在setTimeout一定时间之后，由于setTimeout是宏任务，所以一般会在渲染后执行。但对于异步组件，如果由于网络延迟，导致微任务在宏任务之后入栈，则在setTimeout的回调中仍无法获取子组件的DOM。简单的来说，由于有异步执行顺序的影响，只能保证单独组件内部的执行顺序，无法保证其他组件的解析注册执行顺序。**
8. 组件中对的data为什么必须是函数？
  * 组件中的data写成一个函数，数据以函数返回值形式定义，这样每复用一次组件，就会返回一份新的data，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份data，就会造成一个变了全都会变的结果。

9. keep-alivel
  * 略

10. key的作用
  * 高效更新虚拟dom
  * differ算法

11. 不用key时dom更新算法 diff算法(虚拟dom)
  * 节点类型不同是，删除再创建，不在比较节点之后的子节点，之后的节点都要改变(会引起大量dom修改)，例如有3个dom元素，要在1-2中间添加一个dom，则会因为只有第一个没变，1不用重新渲染，后面的都需要变化。
  * 节点相同，修改节点属性，从而实现更新
